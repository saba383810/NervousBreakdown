"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var utilityScriptSource_exports = {};
__export(utilityScriptSource_exports, {
  source: () => source
});
module.exports = __toCommonJS(utilityScriptSource_exports);
const source = '\nvar __commonJS = obj => {\n  let required = false;\n  let result;\n  return function __require() {\n    if (!required) {\n      required = true;\n      let fn;\n      for (const name in obj) { fn = obj[name]; break; }\n      const module = { exports: {} };\n      fn(module.exports, module);\n      result = module.exports;\n    }\n    return result;\n  }\n};\nvar __export = (target, all) => {for (var name in all) target[name] = all[name];};\nvar __toESM = mod => ({ ...mod, \'default\': mod });\nvar __toCommonJS = mod => ({ ...mod, __esModule: true });\n\n\n// packages/injected/src/utilityScript.ts\nvar utilityScript_exports = {};\n__export(utilityScript_exports, {\n  UtilityScript: () => UtilityScript,\n  ensureUtilityScript: () => ensureUtilityScript\n});\nmodule.exports = __toCommonJS(utilityScript_exports);\n\n// utils/generate_injected_builtins.js\nvar _a, _b;\nvar gSetTimeout = (_b = (_a = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a.builtins.setTimeout) != null ? _b : globalThis.setTimeout;\nvar _a2, _b2;\nvar gClearTimeout = (_b2 = (_a2 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a2.builtins.clearTimeout) != null ? _b2 : globalThis.clearTimeout;\nvar _a3, _b3;\nvar gSetInterval = (_b3 = (_a3 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a3.builtins.setInterval) != null ? _b3 : globalThis.setInterval;\nvar _a4, _b4;\nvar gClearInterval = (_b4 = (_a4 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a4.builtins.clearInterval) != null ? _b4 : globalThis.clearInterval;\nvar _a5, _b5;\nvar gRequestAnimationFrame = (_b5 = (_a5 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a5.builtins.requestAnimationFrame) != null ? _b5 : globalThis.requestAnimationFrame;\nvar _a6, _b6;\nvar gCancelAnimationFrame = (_b6 = (_a6 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a6.builtins.cancelAnimationFrame) != null ? _b6 : globalThis.cancelAnimationFrame;\nvar _a7, _b7;\nvar gRequestIdleCallback = (_b7 = (_a7 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a7.builtins.requestIdleCallback) != null ? _b7 : globalThis.requestIdleCallback;\nvar _a8, _b8;\nvar gCancelIdleCallback = (_b8 = (_a8 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a8.builtins.cancelIdleCallback) != null ? _b8 : globalThis.cancelIdleCallback;\nvar _a9, _b9;\nvar gPerformance = (_b9 = (_a9 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a9.builtins.performance) != null ? _b9 : globalThis.performance;\nvar _a10, _b10;\nvar gEval = (_b10 = (_a10 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a10.builtins.eval) != null ? _b10 : globalThis.eval;\nvar _a11, _b11;\nvar gIntl = (_b11 = (_a11 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a11.builtins.Intl) != null ? _b11 : globalThis.Intl;\nvar _a12, _b12;\nvar gDate = (_b12 = (_a12 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a12.builtins.Date) != null ? _b12 : globalThis.Date;\nvar _a13, _b13;\nvar gMap = (_b13 = (_a13 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a13.builtins.Map) != null ? _b13 : globalThis.Map;\nvar _a14, _b14;\nvar gSet = (_b14 = (_a14 = globalThis.__playwright_utility_script__$runtime_guid$) == null ? void 0 : _a14.builtins.Set) != null ? _b14 : globalThis.Set;\n\n// packages/playwright-core/src/utils/isomorphic/utilityScriptSerializers.ts\nfunction isRegExp(obj) {\n  try {\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isDate(obj) {\n  try {\n    return obj instanceof gDate || Object.prototype.toString.call(obj) === "[object Date]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isURL(obj) {\n  try {\n    return obj instanceof URL || Object.prototype.toString.call(obj) === "[object URL]";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isError(obj) {\n  var _a15;\n  try {\n    return obj instanceof Error || obj && ((_a15 = Object.getPrototypeOf(obj)) == null ? void 0 : _a15.name) === "Error";\n  } catch (error) {\n    return false;\n  }\n}\nfunction isTypedArray(obj, constructor) {\n  try {\n    return obj instanceof constructor || Object.prototype.toString.call(obj) === `[object ${constructor.name}]`;\n  } catch (error) {\n    return false;\n  }\n}\nvar typedArrayConstructors = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  // TODO: add Float16Array once it\'s in baseline\n  f32: Float32Array,\n  f64: Float64Array,\n  bi64: BigInt64Array,\n  bui64: BigUint64Array\n};\nfunction typedArrayToBase64(array) {\n  if ("toBase64" in array)\n    return array.toBase64();\n  const binary = Array.from(new Uint8Array(array.buffer, array.byteOffset, array.byteLength)).map((b) => String.fromCharCode(b)).join("");\n  return btoa(binary);\n}\nfunction base64ToTypedArray(base64, TypedArrayConstructor) {\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++)\n    bytes[i] = binary.charCodeAt(i);\n  return new TypedArrayConstructor(bytes.buffer);\n}\nfunction parseEvaluationResultValue(value, handles = [], refs = new gMap()) {\n  if (Object.is(value, void 0))\n    return void 0;\n  if (typeof value === "object" && value) {\n    if ("ref" in value)\n      return refs.get(value.ref);\n    if ("v" in value) {\n      if (value.v === "undefined")\n        return void 0;\n      if (value.v === "null")\n        return null;\n      if (value.v === "NaN")\n        return NaN;\n      if (value.v === "Infinity")\n        return Infinity;\n      if (value.v === "-Infinity")\n        return -Infinity;\n      if (value.v === "-0")\n        return -0;\n      return void 0;\n    }\n    if ("d" in value)\n      return new gDate(value.d);\n    if ("u" in value)\n      return new URL(value.u);\n    if ("bi" in value)\n      return BigInt(value.bi);\n    if ("e" in value) {\n      const error = new Error(value.e.m);\n      error.name = value.e.n;\n      error.stack = value.e.s;\n      return error;\n    }\n    if ("r" in value)\n      return new RegExp(value.r.p, value.r.f);\n    if ("a" in value) {\n      const result = [];\n      refs.set(value.id, result);\n      for (const a of value.a)\n        result.push(parseEvaluationResultValue(a, handles, refs));\n      return result;\n    }\n    if ("o" in value) {\n      const result = {};\n      refs.set(value.id, result);\n      for (const { k, v } of value.o)\n        result[k] = parseEvaluationResultValue(v, handles, refs);\n      return result;\n    }\n    if ("h" in value)\n      return handles[value.h];\n    if ("ta" in value)\n      return base64ToTypedArray(value.ta.b, typedArrayConstructors[value.ta.k]);\n  }\n  return value;\n}\nfunction serializeAsCallArgument(value, handleSerializer) {\n  return serialize(value, handleSerializer, { visited: new gMap(), lastId: 0 });\n}\nfunction serialize(value, handleSerializer, visitorInfo) {\n  if (value && typeof value === "object") {\n    if (typeof globalThis.Window === "function" && value instanceof globalThis.Window)\n      return "ref: <Window>";\n    if (typeof globalThis.Document === "function" && value instanceof globalThis.Document)\n      return "ref: <Document>";\n    if (typeof globalThis.Node === "function" && value instanceof globalThis.Node)\n      return "ref: <Node>";\n  }\n  return innerSerialize(value, handleSerializer, visitorInfo);\n}\nfunction innerSerialize(value, handleSerializer, visitorInfo) {\n  var _a15;\n  const result = handleSerializer(value);\n  if ("fallThrough" in result)\n    value = result.fallThrough;\n  else\n    return result;\n  if (typeof value === "symbol")\n    return { v: "undefined" };\n  if (Object.is(value, void 0))\n    return { v: "undefined" };\n  if (Object.is(value, null))\n    return { v: "null" };\n  if (Object.is(value, NaN))\n    return { v: "NaN" };\n  if (Object.is(value, Infinity))\n    return { v: "Infinity" };\n  if (Object.is(value, -Infinity))\n    return { v: "-Infinity" };\n  if (Object.is(value, -0))\n    return { v: "-0" };\n  if (typeof value === "boolean")\n    return value;\n  if (typeof value === "number")\n    return value;\n  if (typeof value === "string")\n    return value;\n  if (typeof value === "bigint")\n    return { bi: value.toString() };\n  if (isError(value)) {\n    let stack;\n    if ((_a15 = value.stack) == null ? void 0 : _a15.startsWith(value.name + ": " + value.message)) {\n      stack = value.stack;\n    } else {\n      stack = `${value.name}: ${value.message}\n${value.stack}`;\n    }\n    return { e: { n: value.name, m: value.message, s: stack } };\n  }\n  if (isDate(value))\n    return { d: value.toJSON() };\n  if (isURL(value))\n    return { u: value.toJSON() };\n  if (isRegExp(value))\n    return { r: { p: value.source, f: value.flags } };\n  for (const [k, ctor] of Object.entries(typedArrayConstructors)) {\n    if (isTypedArray(value, ctor))\n      return { ta: { b: typedArrayToBase64(value), k } };\n  }\n  const id = visitorInfo.visited.get(value);\n  if (id)\n    return { ref: id };\n  if (Array.isArray(value)) {\n    const a = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (let i = 0; i < value.length; ++i)\n      a.push(serialize(value[i], handleSerializer, visitorInfo));\n    return { a, id: id2 };\n  }\n  if (typeof value === "object") {\n    const o = [];\n    const id2 = ++visitorInfo.lastId;\n    visitorInfo.visited.set(value, id2);\n    for (const name of Object.keys(value)) {\n      let item;\n      try {\n        item = value[name];\n      } catch (e) {\n        continue;\n      }\n      if (name === "toJSON" && typeof item === "function")\n        o.push({ k: name, v: { o: [], id: 0 } });\n      else\n        o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n    }\n    let jsonWrapper;\n    try {\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === "function")\n        jsonWrapper = { value: value.toJSON() };\n    } catch (e) {\n    }\n    if (jsonWrapper)\n      return innerSerialize(jsonWrapper.value, handleSerializer, visitorInfo);\n    return { o, id: id2 };\n  }\n}\n\n// packages/injected/src/utilityScript.ts\nvar kRuntimeGuid = "$runtime_guid$";\nvar kUtilityScriptIsUnderTest = false;\nvar kPlaywrightBinding = `__playwright__binding__${kRuntimeGuid}`;\nvar kUtilityScriptGlobalProperty = `__playwright_utility_script__${kRuntimeGuid}`;\nvar UtilityScript = class {\n  // eslint-disable-next-line no-restricted-globals\n  constructor(global) {\n    this._bindings = new gMap();\n    var _a15, _b15, _c, _d, _e, _f, _g, _h, _i;\n    this.global = global;\n    this.isUnderTest = kUtilityScriptIsUnderTest;\n    this.builtins = {\n      setTimeout: (_a15 = global.setTimeout) == null ? void 0 : _a15.bind(global),\n      clearTimeout: (_b15 = global.clearTimeout) == null ? void 0 : _b15.bind(global),\n      setInterval: (_c = global.setInterval) == null ? void 0 : _c.bind(global),\n      clearInterval: (_d = global.clearInterval) == null ? void 0 : _d.bind(global),\n      requestAnimationFrame: (_e = global.requestAnimationFrame) == null ? void 0 : _e.bind(global),\n      cancelAnimationFrame: (_f = global.cancelAnimationFrame) == null ? void 0 : _f.bind(global),\n      requestIdleCallback: (_g = global.requestIdleCallback) == null ? void 0 : _g.bind(global),\n      cancelIdleCallback: (_h = global.cancelIdleCallback) == null ? void 0 : _h.bind(global),\n      performance: global.performance,\n      eval: (_i = global.eval) == null ? void 0 : _i.bind(global),\n      Intl: global.Intl,\n      Date: global.Date,\n      Map: global.Map,\n      Set: global.Set\n    };\n    if (this.isUnderTest)\n      global.builtins = this.builtins;\n  }\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = [];\n    for (let i = 0; i < args.length; i++)\n      parameters[i] = parseEvaluationResultValue(args[i], handles);\n    let result = gEval(expression);\n    if (isFunction === true) {\n      result = result(...parameters);\n    } else if (isFunction === false) {\n      result = result;\n    } else {\n      if (typeof result === "function")\n        result = result(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\n  }\n  jsonValue(returnByValue, value) {\n    if (value === void 0)\n      return void 0;\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  addBinding(bindingName, needsHandle) {\n    const data = {\n      callbacks: new gMap(),\n      lastSeq: 0,\n      handles: new gMap()\n    };\n    this._bindings.set(bindingName, data);\n    this.global[bindingName] = (...args) => {\n      if (needsHandle && args.slice(1).some((arg) => arg !== void 0))\n        throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);\n      const seq = ++data.lastSeq;\n      const promise = new Promise((resolve, reject) => data.callbacks.set(seq, { resolve, reject }));\n      let payload;\n      if (needsHandle) {\n        data.handles.set(seq, args[0]);\n        payload = { name: bindingName, seq };\n      } else {\n        const serializedArgs = [];\n        for (let i = 0; i < args.length; i++) {\n          serializedArgs[i] = serializeAsCallArgument(args[i], (v) => {\n            return { fallThrough: v };\n          });\n        }\n        payload = { name: bindingName, seq, serializedArgs };\n      }\n      this.global[kPlaywrightBinding](JSON.stringify(payload));\n      return promise;\n    };\n  }\n  takeBindingHandle(arg) {\n    const handles = this._bindings.get(arg.name).handles;\n    const handle = handles.get(arg.seq);\n    handles.delete(arg.seq);\n    return handle;\n  }\n  deliverBindingResult(arg) {\n    const callbacks = this._bindings.get(arg.name).callbacks;\n    if ("error" in arg)\n      callbacks.get(arg.seq).reject(arg.error);\n    else\n      callbacks.get(arg.seq).resolve(arg.result);\n    callbacks.delete(arg.seq);\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === "object" && typeof value.then === "function") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\nfunction ensureUtilityScript(global) {\n  global = global != null ? global : globalThis;\n  let utilityScript = global[kUtilityScriptGlobalProperty];\n  if (utilityScript)\n    return utilityScript;\n  utilityScript = new UtilityScript(global);\n  Object.defineProperty(global, kUtilityScriptGlobalProperty, { value: utilityScript, configurable: false, enumerable: false, writable: false });\n  return utilityScript;\n}\n';
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  source
});
